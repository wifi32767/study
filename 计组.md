# 第一章
## 1.1 计算机发展历程
经历了电子管、晶体管、中小规模集成电路、超大规模集成电路四个时代。  
摩尔定律：价格不变时，集成电路上能容纳的晶体管数目每隔18个月会增加一倍，整体性能也会提升一倍  
存储器的发展也会遵从摩尔定律  
计算机有两极分化的发展趋势。一极是微型计算机向更微型化、网络化、高性能、多用途的方向发展，另一极是巨星级向更巨型化、超高速、并行处理、智能化方向发展  

## 1.2计算机系统层次结构
计算机系统由硬件和软件组成。  

### 硬件
##### 计算机硬件基本组成
冯诺依曼在研究EDVAC机的时候提出了存储程序的概念，以此概念为基础的各类计算机统称为冯诺依曼机，其特点如下：  
- 计算机硬件系统由运算器、存储器、控制器、输入输出设备五大部件组成
  - 输入设备：将信息转换为机器能识别的形式
  - 运算器：算术运算与逻辑运算
  - 存储器：存放数据和程序
  - 控制器：协调其他部件相互配合，解析存储器中的指令
  - 输出设备：将结果转换成人们熟悉的形式
- 指令与数据以同等地位存储在存储器中，可按地址寻访
- 指令和数据均用二进制代码表示
- 指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置
- 指令在存储器内按顺序存放。通常指令是顺序执行的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序
- 传统冯诺依曼结构以运算器为中心，输入输出设备通过运算器与存储器传送数据，数据传输要经过运算器作为中转
  - 现代计算机以存储器为中心，IO设备和运算器都从存储器读写数据，更多的解放了运算器

在计算机系统中，软件和硬件在逻辑上是等效的。对于同一个功能，既可以用软件实现，也可以用硬件实现。用软件实现成本和效率都更低，用硬件实现成本和效率都更高  
运算器与控制器的关系十分紧密，在大规模集成电路出现以后，二者集成为CPU
$$硬件
\begin{cases}
    & \text{ 主机 }
    \begin{cases}
        & \text{ CPU }
        \begin{cases}
            & \text{ 运算器 } \\
            & \text{ 控制器 } 
        \end{cases} \\
        & \text{ 主存 }
    \end{cases} \\
    & \text{ IO设备 }
    \begin{cases}
        & \text{ 辅存 } \\
        & \text{ 输入设备 } \\
        & \text{ 输出设备 } 
    \end{cases}
\end{cases}
$$

##### 各个硬件的工作原理

**存储器**  
![主存结构](img/计组/主存结构.jpg)  
CPU将想取得的数据的地址存到MAR，主存从存储体中取得数据，写到MDR，CPU取走数据  
CPU将想写入的数据和位置放在MDR和MAR当中，主存向对应的位置写入数据  
这个过程由控制总线传递指令  
存储体是多个存储单元组成的，每个存储单元存储一串二进制数据，称为存储字，其位数为存储字长  
MAR位数反映存储单元的位数，MDR位数等于存储字长  
存储元是存储二进制的电子元件，每个存储元存储一个bit  
在现代的CPU中，MAR和MDR常被集成到CPU中  

**运算器**
![运算器结构](img/计组/运算器结构.png)  

**控制器**
![控制器结构](img/计组/控制器结构.jpg)  
完成一条指令经历三个阶段：
- 取指令，根据PC中的指令地址取出指令，放到IR中
- 分析指令，CU分析IR中的指令
- 执行指令，CU和其他部件控制指令的具体执行

前两个阶段也可合称取指  
CPU区分数据和指令，是依据指令周期的不同阶段  

### 软件
分为系统软件和应用软件两类。  
系统软件是保证计算机系统高效正确运行的基础软件，用来管理整个计算机系统。例如操作系统、数据库管理系统、标准程序库、网络软件、语言处理程序、服务程序    
应用软件是按人的需要编制成的各种程序  

### 计算机的工作过程
计算机的工作过程分为三个步骤  
1. 把程序和数据装入主存
2. 将源程序转换成可执行文件
3. 从可执行文件的首地址开始逐条执行指令

##### 从源程序到可执行文件
以unix系统中的gcc编译器程序为例，读取源文件hello.c，并把它翻译成一个可执行文件hello，整个翻译过程可分为四个阶段  
1. 预处理阶段，把源文件中的注释去掉，对以#开头的预编译指令进行处理，例如将#include后面的头文件插入程序文件，生成一个源文件hello.i
2. 编译阶段，编译器把预处理后的源文件hello.i翻译成汇编语言文件hello.s
3. 汇编阶段，汇编器把汇编语言文件hello.s翻译成机器语言，将这些指令打包成一个可重定位目标文件的hello.o，它是一种二进制文件
4. 链接阶段，链接器把多个可重定位目标文件和库文件链接成一个完整的可执行文件hello

### 计算机层次结构

计算机分为五层结构  
- M0微程序层，执行微指令
- M1传统机器语言层，执行机器语言指令
- M2操作系统层，向上提供广义指令
- M3汇编语言层，执行汇编语言
- M4高级语言层，执行高级语言

计算机语言分为三个级别  
- 机器语言，计算机唯一可以直接识别和执行的语言，由0和1组成的二进制代码
- 汇编语言，是机器语言的助记符，用助记符表示机器指令，必须经过汇编程序的翻译转换成机器语言才能执行
- 高级语言，需要编译器转换成汇编语言或解释器转换成机器语言才能执行，是人类易于理解和使用的语言

## 1.3计算机的性能指标
### 机器字长
机器字长是指计算机进行一次整数运算能处理的二进制数据位数，通常是8的整数倍。机器字长一般等于内部寄存器的大小，字长越长，数的表示范围就越大，计算精度越高。通常与CPU的寄存器位数、加法器有关。

### 数据通路带宽
数据通路带宽是指数据总线一次能并行传输信息的位数。这里说的是外部数据总线的宽度，它与CPU内部的数据总线宽度可能不同

### 主存容量
主存容量是指计算机可存储数据的最大容量，以字节为单位，可用字数 * 字长表示。其中MAR的位数反映存储单元的个数，MDR的位数等于存储字长。

### 运算速度
- 吞吐量，指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，数据能多快地从内存取出和存入，以及所得结果能多块地从内存送给一台外部设备。系统吞吐量主要取决于主存的存取周期
- 响应时间，指系统从用户输入一个指令到系统响应的时长。通常包括CPU时间（运行一个程序花费的时间）和等待时间（用于磁盘访问、存储器访问、操作系统开销、I/O操作等的时间）
- 主频（CPU时钟频率），机器内部主时钟的频率，是衡量机器速度的重要参数。计算机的主频越高，完成指令的一个执行步骤所需的时间就越短，速度越快。单位赫兹
- 时钟周期，是指CPU内部时钟信号的基本周期。主频的倒数，CPU中最小的时间单位，每个动作需要最少一个时钟周期
- CPI，执行一条指令所需的时钟周期数
- CPU执行时间，指运行一个程序所花费的时间。
  CPU执行时间 = (CPI * 指令条数) / 主频 = 时钟周期数 / 主频。
  上式表明，CPU执行时间与指令条数和CPI成正比，与主频成反比。
- MIPS、MFLOPS、GFLOPS、TFLOPS
  - MIPS，每秒执行多少百万条指令。MIPS = 指令条数 / (执行时间 * 10^6) = 主频 / CPI
  - MFLOPS，每秒执行多少百万浮点运算指令。MFLOPS = 浮点操作次数 / (执行时间 * 10^6)
  - GFLOPS，每秒执行多少十亿浮点运算指令。GFLOPS = 浮点操作次数 / (执行时间 * 10^9)
  - TFLOPS，每秒执行多少万亿浮点运算指令。TFLOPS = 浮点操作次数 / (执行时间 * 10^12)

# 第二章
## 2.1 数制与编码
### 进位计数制及其相互转换
采用二进制编码的原因：
- 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本低
- 二进制位1和0正好与逻辑值真和假对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件
- 二进制的编码规则简单，通过逻辑门电路能方便地实现算数运算

##### 进位计数法
略

##### 十进制整数转二进制整数
- 减权定位法
  - 从高位起，从十进制位中逐位分离二进制位
  - 适于手算，程序实现繁琐
- 除基取余法
  - 从低位起除以基数，余数为该位二进制值
  - 适于计算机实现，程序实现简单

##### 十进制小数转二进制小数
- 减权定位法
  - 同样是从高位起逐位分离
- 乘基取整法
  - 将待转换的小数乘以2，整数部分就是这一位的值

##### 二进制整数转换为十进制整数
TODO

##### 二进制小数转换为十进制小数
TODO

### 带符号数的表示
##### 真值和机器数
真值：这是一个数学概念，表示一个数的实际值。  
机器数：这是一个计算机科学概念，表示一个数在计算机中的二进制表示。

##### 原码
最高位为符号位，其余部分为绝对值  
在小数原码中，符号位固定为小数点左边的一位  

##### 补码
$X_补 = X + M (mod M)$  
负数原码转补码：符号位不变，第一个1及其之前不变，其他取反  
负数补码转原码：同上  

##### 反码
正数与原码相同，负数取反  

##### 移码
$X_移 = X + 2^(n - 1)$  

### 浮点数表示
浮点数由阶码E和尾数M组成，$N = R ^ E * M$  
R是底数，与M的基数相同  
数符表示浮点数的正负  

##### IEEE754标准
| | 符号位 | 阶码位数 | 尾数位数 | 总位数 |
| - | ------ | -------- | -------- | ------ |
| 单精度 | 1      | 8        | 23       | 32     |
| 双精度 | 1      | 11       | 52       | 64     |

以32位浮点数为例，最高位$S_0$为数符，其后是8位阶码，采用移码表示。实际偏移量为127，阶码的记录值为真值+127  
其余23位为尾数。除此之外还有4种特殊的定义：
1. 零：尾数全为0，阶码全为0
2. 无穷大：尾数全为0，阶码全为1
3. 非数（NaN）：尾数全为1，阶码不全为0

## 2.2 字符型数据
### ASCII码
略

### 汉字编码
略

## 2.3 数据的处理与存储
### 移位操作
移位操作分为逻辑移位和算术移位。
逻辑移位中，数字代码被当成没有数值含义的纯逻辑代码，可分为循环左移、循环右移、非循环左移、非循环右移。  
算术移位中，数字代码被当成有符号数值，必须保证符号不变。正负数原码的移位规则相同，但补码的移位规则却不同  
正数补码移位规则：数符不变，空位补0  
负数补码移位规则：数符不变，左移时空位补0，右移时空位补1  

### 舍入处理
0舍1入：与四舍五入相似的舍入方法  
末位恒置1：无论最后一位是0还是1，都将其置为1  

### 代码的扩展与压缩
TODO

### 大小端存储模式
存储数据通常以字节为单位，对于位数大于8位的数据，存在如何安排多字节的问题  
大端模式
- 数据的高字节保存在内存的低地址段中，低字节保存在高地址单元，地址从小向大增大，数据从高位往低位放，和阅读习惯保持一致  

小端模式
- 数据的高字节保存在内存的高地址段中，低字节保存在低地址单元  

### 数据字的存储对齐
TODO

## 2.4 基本运算方法
### 定点加减运算
##### 补码加减运算
运算规则：
- $(X + Y)_补 = X_补 + Y_补$  
- $(X - Y)_补 = X_补 + (-Y)_补$
溢出判断：
- $C_f$用表示符号位产生的进位，$C$表示最高有效位产生的进位
- 方法1：
  - $X_f$、$Y_f$分别两个数的符号位,$Z_f$为运算结果符号位。
  - 当$X_f$ = $Y_f$ =0（两数同为正）,而$Z_f$ = 1(结果为负)时,负溢
  - 当出现$X_f$ = $Y_f$ = 1（两数同为负），而$Z_f$ = 0（结果为正），正溢
- 方法2：
  - $C_f \oplus C = 0$，说明没有溢出
  - 正溢时$C = 0$，负溢时$C = 1$
- 方法3：
  - 用变形补码进行双符号位运算（正数符为00,负数符号以11）
  - 若运算结果的符号位为"01",则正溢
  - 若结果双符号为10,则负溢
  - 若结果的双符号位为00或11，无溢出

##### 原码加减运算
被加数与加数符号相同，则数值位求和，否则求差。减法同理  
符号位单独判断

##### 标准移码加减运算
TODO

##### 非标准移码加减运算
TODO

### 定点乘法运算
##### 原码一位乘法
| $C_n$ | 操作 |
| ----- | ---- |
| 0 | $\frac{1}{2}A$ |
| 1 | $\frac{1}{2}(A + X)$ |

![原码一位乘法](img/计组/原码一位乘法.png)

##### 补码一位乘法
| $Y_n$ | $Y_(n + 1)$ | 操作 |
| ----- | ---- | ---- |
| 0 | 0 | $\frac{1}{2}A_补$ |
| 0 | 1 | $\frac{1}{2}(A_补 + X_补)$ |
| 1 | 0 | $\frac{1}{2}(A_补 - X_补)$ |
| 1 | 1 | $\frac{1}{2}A_补$ |

![补码一位乘法](img/计组/补码一位乘法.png)

##### 原码两位乘法
| $Y_i$ | $Y_(i + 1)$ | $C_j$ | 操作 |
| ----- | ---- | ---- | ---- |
| 0 | 0 | 0 | $\frac{1}{4}A$ |
| 0 | 0 | 1 | $\frac{1}{4}(A + X)$ |
| 0 | 1 | 0 | $\frac{1}{4}(A + X)$ |
| 0 | 1 | 1 | $\frac{1}{4}(A + 2X)$ |
| 1 | 0 | 0 | $\frac{1}{4}(A + 2X)$ |
| 1 | 0 | 1 | $\frac{1}{4}(A - X)$ |
| 1 | 1 | 0 | $\frac{1}{4}(A - X)$ |
| 1 | 1 | 1 | $\frac{1}{4}A$ |

TODO

### 定点除法运算
##### 原码不恢复余数除法
每次将被除数$r$左移一位，商的当前位为$Q_i$，进行操作后余数为正则为1，否则为0。根据$Q_i$决定i+1步的操作是加上除数还是减去除数  
第一步固定为减  
| $Q_i$ | 操作 |
| ----- | ---- |
| 0 | $2r_i + Y$ |
| 1 | $2r_i - Y$ |

![原码不恢复余数除法](\img\计组\原码不恢复余数除法.png)

##### 补码不恢复余数除法
采用双符号位，且符号位参与运算
![补码不恢复余数除法](\img\计组\补码不恢复余数除法.png)

### IEEE754浮点数四则运算
##### 加减运算
1. 检测能否简化操作
  - 浮点运算复杂，能简化尽量简化。一个简单做法是检测操作数是否为0
2. 对阶
  - 浮点数加减时必须将阶码调整得一样大。舍去低位会带来更大误差，所以小阶向大阶对齐
3. 尾数相加
  - 做加减运算，结果记为M
4. 规格化
  - 尾数加减后可能不符合规格化要求($1 \leq \vert M\vert < 2$)，因而要将尾数移位，还需同步调整阶码

##### 乘法运算
两浮点数$A = 2 ^ {A_\varepsilon} * A_M, B = 2 ^ {B_\varepsilon} * B_M$  
乘法规则为$A * B = (A_M * B_M) * 2 ^ {A_\varepsilon + B_\varepsilon}$  

1. 检测能否简化操作
2. 阶码相加
3. 尾数相乘
  - 可以用任何一种定点小数的原码乘法实现
4. 规格化


##### 除法运算
运算公式$A \div B = (A_M \div B_M) * 2 ^ {A_\varepsilon - B_\varepsilon}$  
1. 检测能否简化操作，并置商的数符
2. 阶码相减
3. 尾数相除
4. 规格化

## 2.5 数据校验
##### 奇偶校验
最基本的检错码，由n-1位信息元和一位校验元组成。附加一位校验元后，码长位n的码字中1的个数为奇数/偶数

##### 海明校验
设有k位数据，r位校验位，那么必须满足$k + r <= 2^r – 1$  
校验位处在$2^k$的位置上，第i位校验位表示第i位二进制位为1的所有数据按照奇偶校验配平的结果。  
有时候题目中会有全校验位，即校验位为所有数据按奇偶校验配平的结果。  

##### 循环冗余校验
模二运算是一种二进制算法，不考虑进位和借位。模二乘除法与正常四则运算一样演算，但其中的部分积相加采用模二加，部分余数相减采用模二减  
编码方法：
- 将待编码的$k$位有效信息$M(x)$左移$r$位，得$M(x) * x ^ r$
- 选一个r+1位的生成多项式$G(x)$对$M(x) * x ^ r$进行模二除，得到余数$R(x)$
- 将左移r位的有效信息与余数模二加，得到循环校验码

译码与纠错：
- 将校验码用生成多项式$G(x)$进行模二除，得到余数$R(x)$
- 若$R(x) = 0$，则校验成功
- 否则，余数与出错位存在一一对应关系

## 杂项
### BCD码
二进制编码的十进制数。每4个二进制位对应1个十进制位，会有6种状态冗余  

**8421码**：最常用的BCD码，各位从高到低的权重依次为8、4、2、1  
若两个8421码相加之和在9以内，则不需要修正。否则要加6修正并向高位进位  
余3码：在8421码的基础上加3  
2421码：权值从高到低分别为2、4、2、1  
8421码这样每个位有固定权值的称为有权码，余3码这样每个位权值不固定称为无权码。  